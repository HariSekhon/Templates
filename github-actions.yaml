#
#  Author: Hari Sekhon
#  Date: Tue Feb 4 09:53:28 2020 +0000
#
#  vim:ts=2:sts=2:sw=2:et
#
#  https://github.com/harisekhon/templates
#
#  If you're using my code you're welcome to connect with me on LinkedIn and optionally send me feedback
#
#  https://www.linkedin.com/in/harisekhon
#

# MarketPlace:  https://github.com/marketplace?type=actions
#               https://github.com/marketplace?query=publisher%3Aactions&type=actions

# XXX: Edit - badges appear with this name
name: My Workflow

# ============================================================================ #
#                             E n v i r o n m e n t
# ============================================================================ #

# https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
#
# https://docs.github.com/en/actions/learn-github-actions/contexts#github-context
#
# GITHUB_WORKFLOW = name of the workflow (set at top of this file)
# GITHUB_REPOSITORY = owner/repo
# GITHUB_SHA
# GITHUB_REF_NAME (branch or tag)
# GITHUB_REF_TYPE="branch"/"tag"
# RUNNER_NAME
# RUNNER_OS
# RUNNER_ARCH
#
# XXX: can't reference other environment variable to compose larger ones, must be done as a step based workaround, see Steps section of build further down
env:
  repo: bash-tools
  APP: myapp
  ENV: dev
  #DEBUG: 1

  # or generate dynamic image including the registry, see step section
  DOCKER_IMAGE: myimage
  # must generate in Steps
  #DOCKER_TAG: ${{env.GITHUB_SHA}}
  # Docker Container Registry
  #DOCKER_IMAGE: "${{env.GHCR_REGISTRY}}/${{env.APP}}"
  # GCP
  #DOCKER_IMAGE: "${{env.GCR_REGISTRY}}/${{env.CLOUDSDK_CORE_PROJECT}}/${{env.APP}}"
  # DockerHub
  #DOCKER_IMAGE: "harisekhon/${{env.APP}}"

  GHCR_REGISTRY: ghcr.io/harisekhon

  # or configure via aws-actions/configure-aws-credentials in Setup section
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  GCP_SERVICEACCOUNT_KEY: ${{ secrets.GCP_SERVICEACCOUNT_KEY }}
  GITHUB_USER: ${{ secrets.GITHUB_USER }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  CLOUDFLARE_API_KEY: ${{ secrets.CLOUDFLARE_API_KEY }}

  AWS_ACCOUNT_ID: 123456789012
  AWS_DEFAULT_REGION: eu-west-2  # London
  # use secrets from Environments as dynamic variables to share workflow across environments
  #AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  #AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
  #
  # must generate in Steps in order to compose like this
  #AWS_ECR_REGISTRY: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ $AWS_DEFAULT_REGION }}.amazonaws.com
  #DOCKER_IMAGE: ${{ env.AWS_ECR_REGISTRY }}/${{ env.APP }}
  #
  #AWS_DEFAULT_OUTPUT: json
  #AWS_MAX_ATTEMPTS: 3
  #AWS_EKS_CLUSTER: mycluster

  CLOUDSDK_CORE_PROJECT: mycompany-dev
  CLOUDSDK_COMPUTE_REGION: europe-west2
  #CLOUDSDK_COMPUTE_ZONE: "${{env.CLOUDSDK_COMPUTE_REGION}}-a" # or b or c
  #CLOUDSDK_CONTAINER_CLUSTER: myGKEcluster
  GCR_REGISTRY: eu.gcr.io

  #JDBC_URL: jdbc:mysql://x.x.x.x:3306/my_db
  JDBC_URL: jdbc:postgres://x.x.x.x:5432/my_db

  # or set in argocd job
  ARGOCD_SERVER: argocd.domain.com
  ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}

  ARTIFACTORY_URL: https://artifactory.domain.com:8082/artifactory/
  ARTIFACTORY_ACCESS_TOKEN: ${{ secrets.ARTIFACTORY_ACCESS_TOKEN }}

  #SELENIUM_HUB_URL: http://x.x.x.x:4444/wd/hub/
  #SELENIUM_HUB_URL: https://x.x.x.x/wd/hub/

  TF_IN_AUTOMATION: "1"
  TF_WORKSPACE: ${{ env.ENV }}  # run same code against multiple environments

  # for Git Merge branch jobs
  #
  GIT_USERNAME: 'GitHub Actions'
  GIT_EMAIL: 'platform-engineering@MYCOMPANY.CO.UK'

# ============================================================================ #
#                                T r i g g e r s
# ============================================================================ #

# https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows

on: # [push]
  push:
    branches:
      - master
      - main
  pull_request:
    branches:
      - master
      - main
  # https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow#running-a-workflow
  workflow_dispatch:
    #inputs:
    #  description:
    #    description: Some description of this input
    #    default: My Default Description
    #    required: true  # or false
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 0 * * 1'

# ============================================================================ #
#                                    J o b s
# ============================================================================ #

jobs:
  build:
    name: Build
    #needs: [job1, job2]  # dependency jobs
    environment:
      name: production  # use Environment with approval and different Secrets - add this to Deploy stage to allow the build to progress
    timeout-minutes: 10
    # for code scanning to create security alerts (see https://github.com/HariSekhon/Terraform/blob/master/.github/workflows/tfsec.yaml)
    #permissions:
    #  actions: read
    #  contents: read
    #  security-events: write

    # ============================================================================ #
    #               Chooser Runner - OS, Language, Matrix etc.
    # ============================================================================ #
    runs-on: ubuntu-latest
#    runs-on: ${{ matrix.os }}
#    strategy:
#      matrix:
#        os: [ubuntu-latest, ubuntu-18.04, ubuntu-20.04]
#        python-version: ['2.7', '3.7', '3.8', '3.9', '3.10', 'pypy-2.7', 'pypy-3.8']
##        node: [6, 8, 10]
    container: centos

    # job-specific environment variables
    #env:
    #  key: value

    # @<tag/branch/SHA>  # GitHub recommends SHA for 3rd party actions for security
    steps:
    # ============================================================================ #
    #                                  S e t u p
    # ============================================================================ #
    #
    # do checkout first so we can generate dynamic environment variables for branch, tags, SHA etc.
    # https://github.com/marketplace/actions/checkout
    - uses: actions/checkout@v2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}

    # https://github.com/marketplace/actions/setup-python
    - uses: actions/setup-python@v2
      with:
        python-version: '3.x' # Version range or exact version of a Python version to use, using SemVer's version range syntax
        #python-version: ${{ matrix.python-version }}

    # https://github.com/marketplace/actions/setup-java-jdk
    - uses: actions/setup-java@v2
      with:
        distribution: 'temurin' # See 'Supported distributions' for available options
        java-version: '17'  # 8, 11, 16, 17

    # https://github.com/marketplace/actions/setup-node-js-environment
    #
    - uses: actions/setup-node@v2
      with:
        node-version: '14'

    # ============================================================================ #
    #                                 B u i l d
    # ============================================================================ #

    # all run steps seem to operate with 'set -e'

    # Create Dynamic Environment Variables by echo'ing KEY=VALUE >> $GITHUB_ENV
    #
    - name: Generate env GITHUB_SHA_SHORT
      run: echo "GITHUB_SHA_SHORT=$(echo $GITHUB_SHA | cut -c 1-6)" >> $GITHUB_ENV
    - name: Generate env GITHUB_REPO
      run: echo "GITHUB_REPO=$(echo "${GITHUB_REPOSITORY##*/}")" >> $GITHUB_ENV
      #
      # step-specific environment variables
      #env:
      #  key: value

    - name: Environment
      #if: ${{ env.DEBUG == '1' }}
      #if: (github.actor != 'dependabot[bot]')  # skip any PR created by dependabot
      #if: github.event_name == 'push' && contains(toJson(github.event.commits), '***NO_CI***') == false && contains(toJson(github.event.commits), '[ci skip]') == false && contains(toJson(github.event.commits), '[skip ci]') == false
      # multi-line scripts start with |
      run: |
        [ -e /.dockerenv ] && ls -l /.dockerenv
        echo
        cat /etc/*release
        echo
        echo "Environment Variables:"
        echo
        env | sort

    - name: Install git & make
      run: yum install -y git make

    - name: Git Clone
      run: |
        cd /tmp &&
        git clone "https://github.com/harisekhon/$repo"

    - name: Build
      run: |
        cd "/tmp/$repo" &&
        make

    - name: Test
      run: |
        cd "/tmp/$repo" &&
        make test

  # ============================================================================ #
  #                                D o c k e r
  # ============================================================================ #

  docker_build:
    name: Docker Build
    #needs: [job1, job2]  # dependency jobs
    timeout-minutes: 10
    runs-on: ubuntu-latest
    steps:
    - name: Docker Build
      run: docker build . -f Dockerfile -t "${{env.DOCKER_IMAGE}}:latest"

    # workaround for GitHub Actions env not being able to reference other env
    - name: Generate environment variable AWS_ECR_REGISTRY
      run: echo "AWS_ECR_REGISTRY=${{env.AWS_ACCOUNT_ID}}.dkr.ecr.${{env.AWS_DEFAULT_REGION}}.amazonaws.com" >> $GITHUB_ENV
    - name: Generate environment variable DOCKER_IMAGE
      run: echo "DOCKER_IMAGE=${{ env.AWS_ECR_REGISTRY }}/${{ env.APP }}" >> $GITHUB_ENV
    # $GITHUB_SHA is shown in environment dump but evaluates to blank, so use our own generated env var instead
    - name: Generate environment variable GIT_SHA
      run: echo "GIT_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
    - name: Generate environment variable GIT_BRANCH
      run: echo "GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_ENV
    - name: Generate environment variable GIT_TAG
      run: echo "GIT_TAG=$(git tag --points-at HEAD)" >> $GITHUB_ENV
    - name: Generate environment variable EPOCH
      run: echo "EPOCH=$(date --utc '+%s')" >> $GITHUB_ENV
    - name: Generate environment variable DATESTAMP
      run: echo "DATESTAMP=$(date --utc --date="@${{env.EPOCH}}" '+%FT%H%M%SZ')" >> $GITHUB_ENV
    - name: Generate environment variable TIMESTAMP
      run: echo "TIMESTAMP=$(date --utc --date="@${{env.EPOCH}}" '+%F')" >> $GITHUB_ENV

    # don't split Docker Login to separate job as it may happen on a separate machine, resulting in a docker push error of 'no basic auth credentials'
    # also can't dynamically create AWS_ECR_REGISTRY env var for 2 jobs, would have to set statically in workflow env or duplicate generation in each job
    - name: AWS CLI version
      run: aws --version
    - name: Docker version
      run: docker --version
    #- name: Configure AWS credentials
    #  uses: aws-actions/configure-aws-credentials@v1
    #  with:
    #    aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #    aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #    aws-region: ${{ env.AWS_DEFAULT_REGION }}
    - name: AWS CLI whoami
      run: aws sts get-caller-identity
		# doing this in 2 steps so we can differentiate AWS CLI failures from Docker CLI failures
    - name: AWS ECR password
      run: echo "AWS_ECR_PASSWORD=$(aws ecr get-login-password --region "${{env.AWS_DEFAULT_REGION}}")" >> $GITHUB_ENV
    - name: Docker Login ECR
      run: docker login "${{env.AWS_ECR_REGISTRY}}" -u AWS -p "${{env.AWS_ECR_PASSWORD}}"
    - name: Docker Login GHCR
      run: docker login ghcr.io -u "${{env.GITHUB_USER}}" -p "${{env.GITHUB_TOKEN}}"

    # or consider using a script to do all of the below like aws_ecr_docker_build_push.sh from DevOps Bash tools repo - https://github.com/HariSekhon/DevOps-Bash-tools
    - name: Docker Build
      run: docker build . -f Dockerfile -t "${{env.DOCKER_IMAGE}}:latest"

    - name: Docker Tagging
      run: |
        set -eux
        # env.GIT_TAG is not quoted in case it's blank
        for tag in \
                  "${{env.GIT_BRANCH}}" \
                  ${{env.GIT_TAG}} \
                  "${{env.GIT_SHA}}" \
                  "${{env.DATESTAMP}}" \
                  "${{env.TIMESTAMP}}" \
                  latest; do \
            docker tag "${{env.DOCKER_IMAGE}}:latest" "${{env.DOCKER_IMAGE}}:$tag"
        done

    - name: Docker Push Tags
      # push latest last for an atomic cutover of latest once new tags are available
      run: |
        set -eux
        # env.GIT_TAG is not quoted in case it's blank
        for tag in \
                  "${{env.GIT_BRANCH}}" \
                  ${{env.GIT_TAG}} \
                  "${{env.GIT_SHA}}" \
                  "${{env.DATESTAMP}}" \
                  "${{env.TIMESTAMP}}" \
                  latest; do \
                    docker push "${{env.DOCKER_IMAGE}}:$tag"
        done

  # ============================================================================ #
  #                                  D e p l o y
  # ============================================================================ #

  deploy:
    #name: Deploy
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: production  # set up Environment 'production' to require approval to wait here
    timeout-minutes: 10
    steps:
    - name: Deploy
      run: kubectl apply -f ./

  argocd:
    name: ArgoCD Deploy
    needs: build
    runs-on: ubuntu-latest
    container: argoproj/argocd:v2.0.3
    environment:
      name: production  # set up Environment 'production' to require approval to wait here
    env:
      # or set in global env at top
      ARGOCD_SERVER: argocd.domain.com
      ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
    timeout-minutes: 10
    steps:
    - name: ArgoCD Sync
      run: argocd app sync "$APP" --grpc-web --force
    - name: ArgoCD Wait
      run: argocd app wait "$APP" --grpc-web --timeout 600

  # ============================================================================ #
  #                                 S e m g r e p
  # ============================================================================ #

  # https://semgrep.dev/docs/semgrep-ci/sample-ci-configs/#github-actions

  semgrep:
    name: Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    # Skip any PR created by dependabot to avoid permission issues
    if: (github.actor != 'dependabot[bot]')
    steps:
      # Fetch project source
      - uses: actions/checkout@v2

      - uses: returntocorp/semgrep-action@v1
        with:
          config: >- # more at semgrep.dev/explore
            p/security-audit
            p/secrets

        # == Optional settings in the `with:` block

        # Instead of `config:`, use rules set in Semgrep App.
        # Get your token from semgrep.dev/manage/settings.
        #   publishToken: ${{ secrets.SEMGREP_APP_TOKEN }}

        # Never fail the build due to findings on pushes.
        # Instead, just collect findings for semgrep.dev/manage/findings
        #   auditOn: push

        # Upload findings to GitHub Advanced Security Dashboard [step 1/2]
        # See also the next step.
        #   generateSarif: "1"

        # Change job timeout (default is 1800 seconds; set to 0 to disable)
        # env:
        #   SEMGREP_TIMEOUT: 300

      # Upload findings to GitHub Advanced Security Dashboard [step 2/2]
      # - name: Upload SARIF file for GitHub Advanced Security Dashboard
      #   uses: github/codeql-action/upload-sarif@v1
      #   with:
      #     sarif_file: semgrep.sarif
      #   if: always()

    # ============================================================================ #
    #                                 C a c h e
    # ============================================================================ #

    # https://github.com/actions/cache
    # https://github.com/marketplace/actions/cache

    # Cache with matrix

#    - uses: actions/cache@v1
#      with:
#        path: ~/.cache/pip
#        key: ${{ runner.os }}-pip-bash-tools  # ${{ hashFiles('**/requirements.txt') }}
#        restore-keys: |
#          ${{ runner.os }}-pip-
#    - uses: actions/cache@v1
#      with:
#        path: ~/.cpanm
#        key: ${{ runner.os }}-cpanm-bash-tools  # ${{ hashFiles('**/cpan-requirements.txt') }}
#        restore-keys: |
#          ${{ runner.os }}-cpanm-

# ============================================================================ #
# Python
#    - uses: actions/cache@v1
#      if: startsWith(runner.os, 'Linux')
#      with:
#        path: ~/.cache/pip
#        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
#        restore-keys: |
#          ${{ runner.os }}-pip-
#
#    - uses: actions/cache@v1
#      if: startsWith(runner.os, 'macOS')
#      with:
#        path: ~/Library/Caches/pip
#        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
#        restore-keys: |
#          ${{ runner.os }}-pip-
# ============================================================================
# Perl
#    - uses: actions/cache@v1
#      with:
#        path: ~/.cpanm
#        key: ${{ runner.os }}-cpanm-${{ hashFiles('**/cpan-requirements.txt') }}
#        restore-keys: |
#          ${{ runner.os }}-cpanm-
# ============================================================================
# Go
#    - uses: actions/cache@v1
#      with:
#        path: ~/go/pkg/mod
#        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
#        restore-keys: |
#          ${{ runner.os }}-go-
# ============================================================================
# Java / Maven
#    - uses: actions/cache@v1
#      name: Maven Cache
#      with:
#        path: ~/.m2/repository
#        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
#        restore-keys: |
#          ${{ runner.os }}-maven-
#    - uses: actions/cache@v1
#      name: Maven Wrapper
#      with:
#        path: ~/.m2/wrapper
#        key: ${{ runner.os }}-maven-wrapper-${{ hashFiles('**/pom.xml') }}
#        restore-keys: |
#          ${{ runner.os }}-maven-wrapper-
# ============================================================================
# Scala / SBT
#    - uses: actions/cache@v1
#      name: SBT Cache
#      with:
#        path: ~/.sbt
#        key: ${{ runner.os }}-sbt-${{ hashFiles('**/build.sbt') }}
#    - uses: actions/cache@v1
#      name: SBT Ivy Cache
#      with:
#        path: ~/.ivy2/cache
#        key: ${{ runner.os }}-sbt-ivy-cache-${{ hashFiles('**/build.sbt') }}
# ============================================================================
# Gradle
#    - uses: actions/cache@v1
#      name: Gradle Cache
#      with:
#        path: ~/.gradle/caches
#        key: ${{ runner.os }}-gradle-cache-${{ hashFiles('**/build.gradle') }}
#        restore-keys: |
#          ${{ runner.os }}-gradle-cache-
#    - uses: actions/cache@v1
#      name: Gradle Wrapper
#      with:
#        path: ~/.gradle/wrapper
#        key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('**/build.gradle') }}
#        restore-keys: |
#          ${{ runner.os }}-gradle-wrapper-

#  docker:
#    #name: docker
#    runs-on:
#      - ubuntu-latest
#
#    steps:
#    - uses: docker://harisekhon/centos-dev
#    -  name: build & test
#      run: make build test

# ============================================================================ #
# Artifact Upload / Download for sharing between jobs or storing
#
# https://github.com/marketplace/actions/upload-a-build-artifact
#
# - uses: actions/upload-artifact@v2
#   with:
#     name: my-artifact
#       path: path/to/file.jar
#
# https://github.com/marketplace/actions/download-a-build-artifact
#
# - uses: actions/download-artifact@v2
#   with:
#     name: my-artifact  # if name isn't specified, downloads all artifacts to subdirectories of same name
#     #path: path/to/artifacts-dir
#
# ============================================================================ #
# GitHub Script - API calls to GitHub eg. commenting on issue/PR, applying a label to an issue
#
# https://github.com/marketplace/actions/github-script
